# React.js-Training
I am learning React.JS
# React.js-project
I am learning React with this app.. This is part of a course of https://www.udemy.com/course/react-the-complete-guide-incl-redux/learn/lecture

Reacrjs is a JS library for building user interfaces.
If you consider the Netflix You can see it is easy to work with it, with good user interface, the transition happens pretty much instantly, we dont seem to wait for a new page to load. When we work with some website like Netflix, it might almost feel a bit like a mobile app, even though I am using the website. From bobile apps where use that we have smooth transition that is fun to use that app and things happen instantly. Then traditionally in website, when we, for example, clicked a link or a button, our request was sent to a server and new HTML page was sent back to the browser where then could be displayed. So maybe it has the latency where we wait to open a new page.
It is this request and response cycle, which we can break up with JavaScript, because JS is a programing language that allows us as a developer to run logic in the browser and can do things that manupulate what the user sees. 
JavaScript is following an imperative approach. Because you are giving clear instructions, clear step-by-step instructions, what JS in the browser should be doing.having to write all these instructions is very cumbersome.
React uses something which is called a declarative approach for building this component. A component in react is just a JavaScript function. A special kind of function special regarding what it returns that it does return this JSX code, but other than that,
You will not tell React that a certain HTML element should be created and inserted in a specific placeon the user interface as you would be doing it with Vanilla JavaScript, Instead with React and that's really important, you will always define the desired end state, the target state or possibly also different target states and it's then React's job to figure out which elements on the actual webpage might need to be added or removed or updated. And you don't write these concrete DOM updating instructions on your own as you would be doing it with just JavaScript, with React and React component you just define these end states and under which consitions which state should be used and then React will do all of the rest under the hood...and in the end, we just build our own custom HTML Elements and we combined them together for building a user interface.

JS in the browser is able to manipulate to so-called Dom, the HTML elements that are rendered onto the screen. We can manipulate this with JS. That allows us to change what the users see without fetching a new HTML page. So we dont need to request a new HTML page just to present something different to the user. on the other hand When we use just JS we have to write code for every part, is called an imperative approach. React code runs in the Browser.
# Why ReactJS
So Reactjs as a JS library is an extra building block and it is alll about building modern reactive user interfaces for websites. React makes building complex, interactive and reactive user interfaces simple. React embraces a concept called components, Because all user interfaces in the end are made up of components. Components are reusable building blocks in your user interface, and in the end are a combination of HTML code, Css code for styling and possibly JS code for some logic. It uses because of reusable contant and separation of contants an ddont repeat them. You can split your code into multiple small functions
We want to use Reactjs because it makes building modern, rich, complex user interfaces easeir, with a higher level syntax, where we write code in a declarative way, in a declarative component-focused way, we define what we wanna have on the screen. That is why we use the thecnology or framworks like react.
#What we want to learn
-Component-DrivenUser Interfaces
-Building Interactive and Scalable UIs
-A feature called JSX or a special syntax called JSX
-working with Components
-wWrorking with Data
# Creating a new React Project
We have a single html page that we see on the screen constantly changes because of areact. The easiest way of getting started with a React project is to use a tool called Create React App. We can find it in github or creat-React-app.dev. So this is a tool to create a react project, which are basically pre-configured folders with some basic React code files and most importantly a bunch of configuration files which help you build that React App for production use because it turns out that there will be a couple of transformation and optimization steps between developing any React App and running a React App in production but more on that later, And in addition, this project which is created with Create React App, will give you a nice development environment with a development web server which allows you to preview the application locally on your machine.
And it will allow you to preview this applicationin a way where the browser will automatically update the page whenever you make changes in your code and so on.
You need node.js for run this app with some commands.
After install npm, we must run NPM start. We should use it all to keep that development server running as long as we are working on the code, it will automatically update the loaded page in the browser.
# Starting to write codes
W created the required files for writing codes.So we start with index.js, there are import ReactDOM from "react-dom" (That is a library we can see in package.json), css, and App. We can see ReactDOM.render(...)[This is render method] in this file. This is actually the first file which will be executed whenever this page is loaded. The render method get two argument. The first argument is whatever we want to rendder to html page.  The second argument is a default JavaScript DOM API. we use getElementBy Id to select a certain DOM HTML element by its ID from the index.html file from public folder.
The code that we see here, will transform and optimize behind the seence.
Basically we will write to code, in a easy to read developer friendly way with some syntactic sugar, which makes our life as a developer easier, but we'll write code which wouldn't run like this in the browser, and especially not in all supported browsers. Therefore the npm start process, which we started here, which started this development server, which is watching our code, this process will not just watch our code and then take it and deliver it to the browser, but before it delivers it, it will transform it.

<App /> : This is like HTML code that write in JS code. It will be work only because this is transformed before it is delivered to the browser. This is ipport App from ./App(App.js). That is not regular JS syntax here. This is a syntax called a JSX. When we go to the App file we can see a trivial file that in inclulded a function named App that is exported for using in the another file.
In this function You can see a html code that is not regular in HS, but it is inverted by React team.
# What is the JSX 
We got a JSX code that is basically HTML code inside of JS. Indeed, JSX stands dor JavaScript XML, because HTML in the end is XML. It works because of behind screen and npm start process.

# Building Components
We build a component file and give it a name and add a function in it with JSX syntax. When we want to add it to main App.js we import it and write it as a element in the JSX. this is a customer component and we have to use the name which we use in import as a name for element. Because that is how conection is established.
Whereas elements starting with an uppercase character are element defines by you or some other developer<ExpenseItem />.

# Passing Data via "Props" :
We can pass data to the custom component by adding a attribute. And inside of that component, we can then get access to all these attributes which might have been set on our custom component. Again, we're basically building our own custom HTML elements. And just as HTML elements can have attributes, it turns out that with React, our own custom components can also have attributes.There, this concept is just called props instead of attributes. And **props simply stands for properties**. We can set properties of our own custom components. Props are really important, because it allows you to make your components reusable, and it allows you to pass data from another component to this component.

# composition
We build all these components to then build a user interface and we are already doing that. In App.js we're using Expenses, in there we are using ExpenseItem, in there we're using ExpenseDate. Generally, this approach of building a user interface from smaller building blocks is called composition. What if we wanted to create a component which actually just serves as a shell around any kind of other content.
When you use custom componenrs as wrapers, you can not see the content. But we want to use a reusable wraper so we put in wraper div a **{props.children}**. Children is a reserved name. and the value of this special children prop will always be the content between the opening and closing tags of your custom component. This property is now a custom component defined by you. now we have this reusable wrapper component.

# Listening to Events and Working with Event Handlers in React
In React we add an event listener by going to the JSX element, and there we add special prop. But now it's not a prp which sets some value for this button, but instead it's a prop which starts with **on**. Because React exposes all these default events as props which start with on like onClick.
We wrote the function out of onClick and mention to it there(we dont execute it there,so You don't add parentheses here.)Instead, you just repeat the name of the function.

# State
a special concept called state. it is a key concept in React as well. React doesnt matter that a title or something changes, So we should tell React that it should run it again we need to import something from the React library. And we do it as by adding a so-called named import. we want to import single pieces from the React library. And we want to import a function here, function that is called **useState**. This is a function provided by the React library and this function allows us to define values as state where changes to these values should reflect in the component function being called again. We have to define it inside of React component functions that we want to change some part.
**useState()** doesnt work without value, it wants a value. Because wit useState we created a special kind of variable. So we put a initial value as a argument to it. the useState gives us access to this special variable.it also returns a function which we can then call to assign a new value to that variable. So we will be assigning new values by calling a function. That's just how this state variable thing works. And for that useState actually returns an array where the first value is the variable itself, and second value is updating function. We can use array disstructuring []. The first element, is a point at that managed value. and the second element here  is a function which we can later call to set a new thing. with the second paramert that is a function the JSX part run again and assign a new value in some part.
If you have data, which might change, and where changes to that data should be reflected on the user interface then you need state because a regular variables will not do the trick with state, however you can set and change values. And when they do change, React will re-evaluate the component in which the state was registered. And only that component, by the way not any other components, just this component in which this state was registered.
#Event handler
onclick  onChange onInput
If a button, especially with type submit is pressed instead of a form, this overall form element will emit an event to which we can listen and that's the submit event.
onSubmit 
where I wanna react to on submit and then execute some function whenever this form is being submitted.(We put it in the form tag) a part of this default browser behavior is that if you do click this button, the page reloads because the browser actually automatically sends a request whenever a form is submitted
to the server which is hosting this webpage. So in this case to this development server and that's not what we want here. Instead here, we wanna handle this form submission with Java script and manually collect and combine the data and do something with it. We can change this default behavior . we get the event object and on this object we can call a preventDefault() method. This is JS behaviour. So we stay on loading page. We prevent page to load. So now we can create our object here. We store it after push the submit button.
if we just wanted to persist the values, but by using state, we have an advantage. We can now implement something which is called two-way binding, which simply means that for inputs we don't just listen to changes, but we can also pass a new value back into the input. So that we can reset or change the input programmatically. It happen eith value property and put the set function to empty.
So useState is a jS syntax which is called array de-structuring. we use it because useState always returns an array with exactly two elements. and with this syntax, we are pulling these elements out of that returned array and we store them in the separated constants.
# Child to Parent component communication
When we have onChang in input when we type something in it, the function(That is in {}) is executed.
When we write event, it is the default event object that something the browser gives us. We can consider a input as a component, it is simply a pre-built component that we can set some props on that component. And in this input, as a component, with onChange we add a listener.
We can create our own event props if we wanna call it like, and we can expect functions as values and that would allow us to pass a function from a parent component to a child component and then call that function inside of the child component. we can of course pass data to that function as a parameter and that's how we can communicate up from child to parent. Props can only be passed from parent to child, we can't skip intermediate components.
Here we want to add some info from child to parent that is up communicate. So In the Parent file, in the JSX code where we add child component, we add a listener, like onClick or…The name of this prop is better to start with on because in this way we show that the value for this prop should be a function, that the function will be triggered when something happen in this  component, For instance when a form is submitted, this function will be executed. The function of this prop get a parameter.
IN the child component we have to use the prop, the prop is the onName prop that we made in the parent component and we execute it. We can execute this prop because the value of it is a function. We can execute the function in the another component because we are passing a pointer edit through that prop. This is how you can communicate up, how you can to be sure that the child component.
The argument for the pointer function in child component(the function that is in the parent component) is the parameter in function of parent component.
# Lifting the state up
we learned about a very important concept of moving data from a child to a parent component by utilizing props to receive a function from the parent component which we call in the child component. This is close to a key concept which we also already used without even knowing that is the concept call lifting state Up.
We have to consider that we have no direct connection between two sibling components. Instead we can only communicate from parent to child and from child to parent.
We are passing data up to some parent component during coding because we either need that data directly in the app component or in our demo application. because we then want to pass that data down(from parent to child) to another component via props.
You will hear the term Lifting the State Up quite a bit when you were working with React. Whenever you hear that it is about moving data from a child component to some parent component to either use it there or to then pass it down to some other child component.
# Controlled vs Uncontrolled Components & Stateless vs Stateful Components
Presentational VS Stateful components....or Stateless VS stateful components...or dumb VS smart components. It means that in the React App that you bulid, we will have a couple of components that manage some state and components which dont manage any state.
The components that are a stateless component also called presentational or dumb component, Because they dont have any internal state, they are just there to ouput some data
In most React applications, we will have more presentational and dumb components than smart or stateful components. Most components indeed will only focus on outputting something, on having some JSX code, maybe some transformation logic like this here and maybe some css code
# Rendering List of Data
When we want a **dynamic exprossion** in our JSX code, that is done with curly braces. THen we can execute JS expressions there. For instance, map() takes a function as a argument and that function executes for every elements in the array, and it gets that element for which it,s currently executing as a parameter. So it is so useful for preventing of repeating our similar items with different data.
**Using stateful Lists**
In Reacr we khonw that when we add a new property to an array, nothing would happen because we learned that just because we change a variable, React won't update a component. Instead to achive that, you need to use state. So we use the map() method and a state to create a dynamicy list.
# Understanding Keys
**Warning:Each child in a list should have a unique "key" prop.**
React has a special concept when it comes to rendering lists of data, a concept which exisis to ensure that React is able to update and render such lists efficiently without performance losses, or bugs, which may occur.
When we look at the element tools, go to the elements tab, we can see the list of div that we add or we had.When we add a new element we can see last of the element is flashed as soon as we click in the add item button, it means it added by the browser. When we go to the div we can see h2 tag will be flashed when new one is added So what actually happens here when I add a new item is that React, renders this new item as the last item in this list of div's and updates all items and replace their content, such that it again matches the order of the items in my Array. REact updates the content inside of every item
to match the Array content again.
The final result, therefore is correct here but from a performance perspective this is not great because all items are visited and updated and it can even lead to bugs. If the expense items would be state full items and we would have some state managed inside of that. Then if, for example, our first item, if it has a certain state if we add a new item the old first item would be overwritten with the new first item. Hence any state changes we might've had in there would be lost. So besides potential performance issues we could also run into bugs.
**Why the React has this behaivour?**
It is because it has no other way. We have to tell the Reat that which item is new. We do that with going to items where we have map method or any where that we can and we j=have to add special prop to this item. that is **key** prop. This is a prop that you can add to any component(Custom component or html element). With adding key prop we help React to identify the individual items. We have to set a uniq value per list item. So we have to have key prop when mapping out lists of items.
# Conditional Content
Conditional content is about rendering different output under different conditions. There are some ways that we can see in the code.

# Styling React Components
Building web app with React is not just about composing components together and making sure that the logic works correctly. That arguably is the most important part, where at least it is the biggestt reason for using React. But building React app is also about styling those apps. React is also about:
1.Conditional & Dynamic Styles
2.Styled Components
3.CSS Modules

**Setting dynamic inline styles**:
One of them is trim(), trim method is a built in method that removes excess whitespace at the beggining or end of a string.
We can also add new class in the special setuation with in template literal`` and ${}.
We can use style-components for styling the html element instead of add css file to component.
# Fragments, Portals and Refs
**JSX Limitations & Workarounds** : JSX is that code you return in your Components which in the end will be rendered to the real DOM by react. One of the JSX limitation that we always face in it, if we have adjacent root level JSX element side by side, we will get an error. We can not return more than one "root JSX element (you also cant store more than one "root" JSX element in a variable), because it is not also valid JS. Your JSX code translates into REact creat element, so if we have two JSX element side by side we have two React.createElement() in one return. So it is impossible. But they can be children and these children of that root element would be the third and fifth and so on argument.
we can solve this problem with wrapping the adjacent elements with a div(or other elements). so we have one value for return.
Second way is that we can use a native JS array and we have to seperate them with comma. If we do it, we have to specify a key for every element in the array.
Besides with wrapping element we might have a lot of div in the final HTMl file because of JSX limitation(div Soup).
So we can use the dirty trick for solving this problem. We will use the wrapper which jst return props.children.
We can also use the Fragments for solving this problem. It is a empty wrapper component: it doesnt render any real HTML element to the DOM. But it fulfills React's/JSX' requirement.
**React.Fragment**: We can also use the React.Fragment or we can put the tag empty. The React.Fragment always work, we just be sure that we are importing React or we can import Fragment in the curly braces from React, So with this we just can use the name,<Fragment/>. Fragments allow us write cleaner code, to end up with less unnecessary HTML elements on the final page.
**React Portals**: It is also help us write cleaner code. For using portal we need two things, we need a place that we want to port the component to and then we need let the component know that it should have a portal to that place. To mark that place, we go to the poblic folder and there into the HTML file which is being rendered in the end. It is common that you add a div with an id which you will then use to identify this place later. We can identify some root for different kinds of components thst should be portaled there.For adding it into te component we will use ReactDOM, createPortal with pointer (document.getElementById()).
React is the library that has all the React features, state management, insen, backed-in. React-dom uses React to bring that logic and these features into the web browser. To make them compatible to working with the DOM, put in ohter words, the react library itself doesnt care whether you run it in an environment that has a DOM or if would use it to build a native app. React-dom is kind of the adapter for react to the Browser and therefore since now we are going to portal something into a different place in the real DOM,we need to import from react-dom.
**ref**s : ref is refrences. They allow us to access to other DOM elements and work with them. With refs, we can set up a connection between a HTML element which is being rendered in the end and our JS code. For that, first of all, we need to create a ref which we do with the help of another react hook. we use useRef hook. like other hook it is used inside of function components.
It takes a default value you want to initialize it to and return a value that we will use it. After define the function with ref, we add the prp ref in the JSX which we can add to any HTML element. We can connect any HTML element to one of our references. It is very commen for input, because it wants to fetch input data. When the react render, it will store the value into nameOfRef to the native DOM element. When we use the ref , we will have object that has a current property. The current prop holds the actual value that ref is connected with. In this object with current property, is stored something else, is the actual DOM node which is manipulate and do all kinds of things with, but we dont manipulate it. So we can store nameOfRef.current.value and use it. So we dont need useState to get our value anymore.
Which one better to use? "useState or useRef" : If we want to read a value , refs are probably better. a little bit hacky approach of then still manipulating the input fields and resetting them if you want to do that.
**Uncontrolled vs controlled components** : if we access values with a ref, so therse input components would be uncontrolled components. Because they are internal state, so to value which is reflected in them is not controlled by react. we rely on the default behaior of the input where a user of course is able to enter something and that entered value is reflected, we then jst fetch it with a react feature but we dont feed data back into the input. When we use refs, we have uncontrolled input components. But for useState, where we update that state on every keystorke snd we feed that state back into the input with the value prop, it is controlled approach. those input fields are controlled components because their internal state is controlled by react.

# Effects, Reducers, Refs, Context and ImperativeHandle:
What is an Effect (or a side Effect)? When We say effect we mean Side Effect.
The React app and the React library itself has one main job, to render the UI, to react to our user input, to re-render the UI when it is needed.
The main job is to bring something onto the screen and to make sure that the user may interact with that something and that what’s shown on the screen may change based on certain events.
We want to evaluate and render the JSX code and the DOM. We want to manage state and props to make sure that every component has the data it needs and that we reflect the user input correctly. 
We want to React to user events as mentioned and of course React  is there to also re-evaluate our components and their JSX code and manipulate the real DOM as needed.
Therefore side effects are everything else that might be happening in our application.
you might be sending a Http request to then draw something onto the screen once you got the response, but sending the request itself and handling potential errors and so on that's not something you need React for, that's not something React cares about, that's not what React is.
So we have a better tool for handling side effects and that is a special React Hook.
The useEffect()Hook is simply another built in Hook. Another function that we can run inside of your component function that will do something special. The useEffect()Hook is called with two arguments with two parameters. The first argument is a function that should be executed after very component evaluation if the specified dependencies changed. The specified dependencies are the second argument that you pass in. That is an array full of dependencies and we will see how these dependencies look like throughout this module. So an array full of dependencies and whenever such a dependency changes that first function will re-run. Therefore in the first function we can put any side effect code and that code will then only execute when the dependencies specified by you changed, not when the component re-renders.
For example we can use useEffect()Hook when we want to store some user info. The browser has multiple storages we can use. The most common storage for this would be cookies or local storage. We want to use localStorage that is a global object which is available in the browser >>localStorage.
**Using the useEffect() cleanup function:
Sometimes we also have an effect that needs to do some cleanup work. For exemple imagine we execute a function essentially on every keystroke. Sometimes it is important, For instasnce when we send an HTTP request to some backend. If we do something when user stop typing called debouncing. we can use setTimeout() and in it we put the function that we want to execute after a specific time. ANd also we return a function that is anonymous arrow function that is called cleanup function. This willl run as a cleanup process before useEffect executes this function the next time. The cleanup function will run whenever the component you are specifying the effect in unmounts from the DOM. This is no run before the ferst side effect function execution.
clearTimeout is built into the browser, it is clean the timer that we set. If we put the useEffect with just log withouth dependencies, it will be executed after every component render cycle. NOw if we put a empty arry, the function executes for the first time this component was mounted and rendered, but not thereafter, not for any subsequent render cycle, It realy only run once. Now if we add a dependency like entered email or entered password, now this function rerun whenever the component was re-evaluated, and the state that we use,changes. and we see effect cleanup being triggered and it triggers before the effect function run.

**useReducer()** the next React Hook:
The usereducer is another built in Hook and it is a bit like useState, but actually with more capabilities and especially useful for more complex state, for example if it got multiple states, multiple ways of changing it or dependencies to other states. So useState often becomes hard or error-prone to use and manage. it is easy to write bad, inefficient or buggy code in such scenarios. the useReducer() can be used as a replacement for useState() if we need more powerful state management.
const [state, dispatchFn] = useReducer(reducerFn, initialState, initFn); useReducer just like useState always returns an array with exacyly two values. the state snapshot used in the component re-render/ re-evaluation cycle. because it is a state management mechanism like useState. We also get the function that can be used to dispatch a new action (i.e trigger an update of the state), that allows you to update that state snapshot. Instead of setting a new value, you will dispatch an action. and that action will be consumed by the first argument that you pass to useReducer a so-called reducer function. This is a function which gets the latest state snapshot automatically because this function will be called by React and it gets the action that was dispatched. Because React will call this reducer function whenever a new action is dispatched. Then the reducer function also should do one important thing. It should return a new updated state. It is a bit like the fuction from of the useStaet hook, but an extended version of that. We can also add the initial state and initial function that set the initial state programmatically.
Adding Nested Properties As Dependencies To useEffect
We used object destructuring to add object properties as dependencies to useEffect().

const { someProperty } = someObject;
useEffect(() => {
  // code that only uses someProperty ...
}, [someProperty]);
This is a very common pattern and approach, which is why I typically use it and why I show it here (I will keep on using it throughout the course).

I just want to point out, that they key thing is NOT that we use destructuring but that we pass specific properties instead of the entire object as a dependency.

We could also write this code and it would work in the same way.

useEffect(() => {
  // code that only uses someProperty ...
}, [someObject.someProperty]);
This works just fine as well!

But you should avoid this code:

useEffect(() => {
  // code that only uses someProperty ...
}, [someObject]);
Why?

Because now the effect function would re-run whenever ANY property of someObject changes - not just the one property (someProperty in the above example) our effect might depend on.

**useState() vs useReducer():**
Generally, we will know when we need useReducer() (=> when using useState() becomes cumbersome or you’re getting a lot of bugs/ unintended behaviors).
The useState() is the main state management “tool”. It is great for independent pieces of state and data. It is great if state updates are easy and limited to a few kinds of updates.
The useReducer() is great if you need more power and with more power we simply mean that we can write such a reducer function that can contain more complex state updating logic where we always are guaranteed to work with the last state snapshot. And where we can move that potentially more complex logic out of your component function body into a separate reducer function. It should be considered if we have related pieces of state/data. It can be helpful if we have more complex state updates.

**Introduce React Context (Context API)** :
We have a concept called React Context, and this then allows us to, for example, trigger a action in that component-wide State Storage, and then directly pass that to component that is interesting without building such a long prop chain. That allows us to solve our problem in more elegant way.  We have this React context concept which allows us to manage state kind of behind the scenes in React. We actually are able to directly change it from any component in our App and directly pass it to any component in our App without building such a prop chain.
When we import React from "react" >>> React.creatContext() takes a default Context, and the contax here really is just your app or component white state. It could be something simple like just a string, if your app white or a component white state is just some texts. Often though it will be an object. To use Context in our app we need to do two things. We need to provide it which basicaly tells React where is it, all component that are wrapped by it should have access to it and besides providing, you then need to consume it, we need to hook into it, we need to listen to it. Providing means that we wrap in JSX code all components that should be able to tap into that context or listen to that context. For accessing to property on this AUTH-cONTEXT OBJECT THAT CONTAIN A COMPONENT we use provider. AuthContext.Provider is hte component we can use in our JSX code and we wrap it around other components and all their descendant components.and all their descendant components (all those children). After that we have second part that is listening part. To get access to our value we need listen and we can listen in two ways. We can listen by using Auto-Context consumer or by using a React Hook.
We have .Provider, now we have consumer that takes a child which actually should be a function beteen curly braces and as argument we will get our Context data. In this function we should return JSX code which should have access to that data.
 we do have a default value here, but this default value will actually only be used if we would consume here without having a provider. So technically the provider is not even needed, however, you should memorize this pattern I explained earlier, where you need the provider. Technically, you don't need it if you have a default value, but in reality, you will use Context to have a value which can change and that will only be possible with a provider. We will use Context to have a value which can change and that will only be possible with a provider. ThereFor to make sure that this soes not crash, in the provider we cab add a value prop and this has to be named value. because this is not a component by we nd to do that we can also pass our object(into the value).
 
 There is other way to use context:
 **Tapping into Context with the useContext Hook**: Another Hook that is built into React. and it allows us to use the Context, it allows us to tap into a Context and listen to it. For using it, we call useContext in our React Component Function, and we pass the context appointer at the Context you want to use to it. What we get back is the context value, so we store it into the constant. It sounds a little bit elegent.
 For comparitive the props and context, in more cases, we will use props to pass data to components and to make them reusable. Only if we have something which you would forward through a lot of components and we are forwarding it to a component that does something very specific. Like for example, the navigation where this button will always log the user out. In such cases, we want to consider context.
 
 **Building and Using a custom context Provider component** :
 Another thing that We might consider is depending on our application structure and how We are manging our data. We also might want to pull more logic out of for example App component and creat a seperate context Managment component.
 Context-limitation:  It can be great for app-wide or component-wide state. So essentially states that affects multiple components. It's not a replacement for component configuration. So props for configuration, context for state management across components or possibly across the entire app. But even then we have limitations, React Context is specifically not optimized for high frequency changes. React context also should not be used to replace all component communications on props. Props are still vital and important for component configuration and short "props chains"might not need any replacement.
 
 **Learning the rules of Hooks**:
 There are two main rules we have to know when it comes to working with react hooks. React Hooks are simply all those functions that start with use:
 1. First rule is we must call React Hooks in React functions that means in React component functions or in Custom Hooks.
 2. We must to only call React Hooks at the Top level of your react component functions or your custom hook functions. Don't call Hooks in nested functions and Don't call them in the any blck statements.
 **About useEffect Hook** there is a unofficial rule>> always add everything you refer to inside of useEffect() as a dependency.
  **Diving into Forward refs** :
The next hook I want to show you allows us to interact with the Input Components imperatively, which means not by parsing some state to it that then changes something in the Component, but by calling a function inside of a Component, for example, which is something you won't need to do often and you shouldn't do often because it's not the typical React pattern you want, but sometimes it is helpful. It is useRef and focus>>>we could now use inputRef.current.focus, And the focus method is a method that is available on the Input DOM object, to which you got access through this Ref. So a rare use case, but you could face it at some point.

**UseImperativeHandle**: Is another Hook has a strange name, but it is  a hook that allows us to use this Component or Functionalities from inside the component imperatively. Which simply means not through the regular state props management, not by controlling the component through state in the parent Component, but instead by directly calling or manipulating something in the Component programmatically. This is something that we rarly use. we always use a alternative for it. Anyway it has two prameters, second one is a function that should return an object which inclulds all the data we can use them from outside. and the first one is that we get as an argument from Component Function. The first argument is always works with props, and second is that we use in the first argument in useImperativeHandle that is for connecting eith parent compenent. In order to enable this second argument here, we need to export our Component function in a special way. that is come from react and called **React.forwardref**. When we put it in front of the Component function still is a React Component but a React Component that is capable of being bound to a ref. With the useImperativeHandle and forwardRef, you can expose functionalities from a React Component to its parent Component to then use your Component in the parent Component through refs and trigger certain functionalities.

# How React works behind the Scenes:
React is a JS library for building user interfaces. We work with components. We see ReactDOM that is our interface to the web. React.js doesn’t know the web. It doesn’t know nothing about browse. React knows how to work with components. It is ReactDOM to which matters in the end and which ultimately needs to bring real HTML elements to the screen.
But React is just a library that manages components, that manages state and that manages different components states and that finds out how components might need to change and which differences you might have from a previous state of a component compared to the current state. And React hands all that information regarding what changed and what should be visible on the screen no matter what screen that is.
Therefore ReactDOM is responsible for working with the real DOM, which is part of the browser,  bringing something onto the screen, which user is then able to see.
So React check the components and will let ReactDOM know about that to bring them to screen.
React  uses a concept called the virtual DOM. ReactDOM receives the differences and then manipulates the real DOM.
Re-evaluating components is not equal with Re-rendering the DOM.
We have to differentiate between our component part (React part) and the real DOM.
Our components are re-evaluated whenever props, state or context changes. React then executes that component function again. Now the real DOM on the other hand is only updated in the places where it needs to be changed based on that difference React derived
between the previous state of a component and its tree and the current state after the state prop or context change. So the real DOM is not changed all the time. It's changed rarely and only when needed.
And that's important for performance, because making a virtual comparison
between the previous state and the current state, that's fairly cheap and easy to do.
That happens only in memory. Reaching out to the real DOM, that's rendered in the browser
is pretty expensive from a performance perspective, because working with the real DOM just turns out to be a performance intensive task. Of course not a tiny change in one place, but if you do that tiny change in a lot of places all the time, then your page might become slow because you're working with the real DOM too much.
And that's my React has this structure of doing virtual comparisons with that virtual DOM and then only passing the changes between your last snapshot and the current snapshot to the real DOM. That's how React works here. For we add just a paragraph, react just add it without re-render for example header. But it is really important to understand that if a component is re-executed all its child components will also be re-executed and re-evaluated. So therefore of course not just a DemoOutput component
is re-evaluated. For  any more child components  if they would have child components though those child components would also be re-evaluated. And, therefore, you as a developer can tell React that it should only re-execute this DemoOutput component
under certain circumstances.  
How can we tell React that it should behave like this?

# React.memo()
And we simply wrap our component, with React.memo. This is for functional components. So React.memo allows us to optimize functional components. Now, what does memo do?
It tells React that for this component, which it gets as a argument, React should look at the props this component gets and check the new value for all those props and compare it to the previous value those props got. And only if the value of a prop changed, the component should be re-executed and re-evaluated. And if the parent component changed but the prop values for that component here did not change,
component execution will be skipped. Why aren't we using that on all components
if it allows us to optimize them? Because this optimization comes at a cost.
The memo method here tells React that whenever the App component changed,
it should go to this component here and compare the new prop values to the previous prop values, so therefore React needs to do two things.
It needs to store the previous prop values, and it needs to make that comparison.
And that, of course, also has its own performance cost. And it, therefore, greatly depends on the component you're applying this to whether it's worth it or not because you're trading the performance cost of re-evaluating the component for the performance cost of comparing props. And it's impossible to say which cost is higher
because it depends on the number of props you have and on the complexity of your component and the number of child components your component has.
Of course, React.memo can be a great tool if you have a huge component tree
with a lot of child components. And on a high level in the component tree, you can avoid unnecessary re-render cycles for the entire branch of the component tree.

# Why does React.memo() work for some case, but doesn’t work for some others case?
you can avoid unnecessary re-render cycles for the entire branch of the component tree. Like in this case, by avoiding the re-evaluation of DemoOutput, we're also automatically avoiding the re-evaluation of MyParagraph even though we're not using React Demo in there just because we cut off this entire branch, so this entire branch of the component tree. That is something where React.memo can definitely be worth it. If you, on the other hand, have a component where you know it's going to change
or its props values are going to change with pretty much every re-evaluation
of the parent component anyways, then React.memo doesn't make a lot of sense
because if the result is that the component should re-render anyways, well, then you can also save that extra comparison of the prop values.  That's then just some overhead cost, which is not worth it.  And, of course, ultimately, as always,  it depends on your app size. For small apps, for small component trees, and so on, for all of that, it might simply not worth it to add this. But for larger apps where you can cut off entire branches of unnecessary re-evaluations, it might very well be worth it.
You just don't wanna wrap every component with React.memo. Instead, you wanna pick some key parts in your component tree which allows you to cut off an entire branch of child components. That's way more effective than doing this on every child component.
So now that we learned about React.memo, let's also apply it to the Button. We can argue whether that's good or not because the Button is a trigger component, so doing that prop-checking might not be worth it. On the other hand, we as a developer know
that this Button realistically doesn't re-change, so re-evaluating the Button all the time
shouldn't be worth it.  There's nothing on it that changes, right?  We have the same text, we have the same function, so why don't we wrap it?
For that, let's go to Button and use React.memo down here and wrap our Button component with it. Now, you will see something interesting if you do that. If you save that and reload the app, of course, initially, we see Button RUNNING. But now if we click Toggle Paragraph, we, again, see Button RUNNING.  Why is that happening? That makes no sense, right?
Well, we see Button RUNNING again and again because, actually, its prop values did change. That's strange, right?
If we have a look at that, it only gets one prop, onClick, or, actually, two props, the children here, but both prop values never change. We always have the same text,
and we always have the same function, right? Well, this is one of the most common got chas with React.
Keep in mind that this App component is just a function in the end, and it re-executes like a normal JavaScript function because it is a normal JavaScript function if your state changes. The only magic thing here is that the function's going to be called by React
and not by you. But then, it still executes like a normal function, which means all that code executes again, and that has one important implication. Of course, this function
which you pass to the Button is re-created. This is now a brand new function for every render or every execution cycle of the App function because in the end it's just a normal constant which we recreate. All that code in here is executed again, so, of course, a new function is created. This is not the same function all the time.
It's a function that does the same thing. But technically to JavaScript, it's a brand new function for every time the App function is being executed.
That's, by the way, also true for false being passed to DemoOutput.
Previously, I said that this never changes, even that technically was not correct.
This App function is re-executed, therefore a new false value is created.
So even if we had false in the last render cycle too, now we have a new false.
But if that's the case, why does React.memo then work on the DemoOutput but not on the button? What's the difference between false and the function here?
If a new false is created and a new function is created, shouldn't then both components be re-evaluated? 
Well, for that, you have to keep in mind that false is a boolean, and booleans like strings and numbers are primitive values in JavaScript.
Now, what React. memo does in the end is it has a look at all the prop values, and in the end it compares props. show to props. previous. show, you could say.
This is not exactly what it does internally, but you can imagine it like that. So in the end it has a look at the previous value for the show prop and compares it to the current value, and it does so with a regular comparison operator. Now, for primitive values, that will work because for primitive values, if I compare two booleans, I get true if they are the same. If I compare two strings, I get true if they are the same.
Now, technically, that is a different Boolean than this here, and that's a different string than this. These are two different values But for primitive values, this comparison works. Now, that's not true if you compare arrays or objects or functions. For comparing two arrays, let's say, which look similar to us humans, in JavaScript they are not equal. And that's not React-specific, that is JavaScript. And attached to this lecture, you find an article and a video on primitive and reference values so that you really understand this because that's a core concept of JavaScript. Now, it's important to understand that functions are just objects in JavaScript. Again, not React-specific, that's just JavaScript.
So here a new function object is created with every time the App function runs, and this function object is passed to the onClick prop. Now, therefore, Button in the end compares props.onClick to props.previous.onClick, for example. And in there we have two function objects.  Now, two objects, even if they have the same content, are never equal in JavaScript when compared like this.  And, therefore, React.memo finds out that the value changed just because of how JavaScript works. We can make React Memo work for prop values that are objects as well. We just need to tweak the way we create and store those objects a little bit. There is an extra hook provided by React
that helps us with that.  And that is the Use Callback Hook.
# useCallback Hook:
useCallback is a hook that allows us to basically store a function across component executions. So it allows us to tell react that we want to save a function and that this function should not be recreated with every execution. With that one in the same function object is stored, so one in the same place in memory and therefore the comparison does work. useCallbak will save a function of our choice basically somewhere in React’s internal storage, and we will always reuse that same function object then when this component function executes. For using it, we just wrap the function we want to save with it and pass our function as a first argument to use callback and useCallback then returns that stored function and when the app function reruns useCallback will look for that stored function which react stored for us and reuse that same function object. So if we know that this function should never change, we can use Use Callback to store it.
UseCallback like useEffect actually wants a second argument and it wants it even more than useEffect and just like for useEffect the second argument should be an array, an array of dependencies. If we have an empty array of dependencies which basically tells React that this callback with this function which we want to store it will never change that it has no dependencies. But why we have to have this dependencies when the function has always the same logic across rerender cycles?
Keep in mind that in JS functions are closures, which means they close over the values that are available in their environment. If we have a other function and make a closure, that the inner function work with out variable. Here if we define the useCallback, it will be stored in memory and stored the out variable for using. So when it re-render it access to old variable that stored, it is the closure behaviour. So for using the updated variable we must put it in the array as a dependency.
# How React work with state
We have to know that React when see useSate, create a new state variable and React know this useState is for which component, so when useState is being called, no new state is being created. Instead react recognizes that it already  has a state for this component, and updates that state as needed. As long as a component stays attached to the DOM, state is only updated after that first initialization.
**But now How React handle the state updates**: When the update happens the new state does not update immediately, instead schedules a state update with the new data. But that is now a scheduled state change, React is aware of it, React plans on processing it. React doesn’t process that immediately. In reality it sounds instant, because this process is very fast, But React reserves that and postponing that state change. Because in this moment React has a higher priority than changing some text on the screen for example. So because of multiplying updates can be scheduled at the same time. We can use the function form for argument of function of useState. It helps for re-rendering process That's why this function form is helpful because there React will actually ensure that for every outstanding state change, it looks into the latest state and gives you that and does not use the latest state from the last time he component was re rendered. That's an important difference between when the component was re-rendered, and when a state change was scheduled.
In one situation we want to state updates that depends on some other states. In this case, on the other hand we want a state update that depends on the same state just a previous snapshot of that state.
# useMemo Hook:
It allows us to memorize means store, any kind of data which we want to store, just like useCallback does it for function. One argument is a function and second argument is an array of dependencies  you will use useMemo far less often than you use useCallback because memorizing functions is much more useful, and you need that more often than memorizing data. You essentially wanna memorize data
if it would be performance-intensive to recalculate something based on it. We have to keep in mind that when we use the memo, it store data and occupies some memoryand this storing functionality takes up some performance. So it is not something that we have to use always.
# An Alternative Way of Building Components: Class-based Components:
Besides building components as functions, we can also define components with classes. In most modern React projects, we are probably not going to use this approach. For components we build a function that receives props and then returns the JSX code that should be rendered to the screen. Components are regular JS functions which return render able results (typically JSX). So we call it Functional components.
Components can also be defined as JS classes where a render() method defines the to-be-rendered output.
Using Functional Components is the default ando most modern approach of building components these days. In most modern React projects, we will therefore pretty much work with functional components only.
We might never build a single class-based component there because nowadays with the exception of error boundaries, there is no reason to go for classe-Based Components, Except for personal preferences. 
The Classe-Based Components exist because they were required in the past. In the past, Which means prior to React 16.8, there were scenarios and use cases where you needed Classe-Based Components. Specifically when dealing with state and with side effects, you had to use Class-Based Components. Traditionally, prior to React 16.8, you could not change state in functional components and you could not really handle side effects there either. That changed with react 16.8 because that React version introduced a concept called React Hooks, which are all these Hooks, these functions starting with use. These are functions for functional components which bring features to functional components which previously were reserved for Class-Based components. Instead class-Based components cannot use React Hooks.
# error Boundaries:
Sometimes somthinf=g goes wrong in the application, here it doesn’t mean a bugs, sometimes there are errors which we cannot prevent or which are simply being used to transport information that something went wrong from one part of the application to another part. So we can generate an error with componentDidUpdate() and throw new Error() with conditional statement. But we don’t want whole of the application to crash, so we use try/catch in regular JS code. We can use it in react but we have to know it doesn’t work in parent component because in parent component it is inside of the JSX code, so we cannot wrap this JSX code with try/catch. So in such a case, we can build and utilize an error boundary. For it we make a component for this error boundary and it is a JS file and in there we will create s regular component, and we will build it as a classBased component which implements the componentDidCatch lifecycle method. The componentDidCatch lifecycle method can be added to any class-based component and whenever we add it to a class-Based component, it makes that class-Based component an error boundary. We cannot add it to functional components and there is no equivalent for functional components in this moment.
This lifcycle method will be triggered whenever one of the child components throws an error or generates an error.  We return this.props.children in the render(), because we want to wrap our error boundary component around components which should be protected b that component.
# Sending HTTP request:
In this part we learn about how we can connect our React application to a backend, to a database. Because more app need to fetch data from a database or store some data in a database eventually. Now we want to know about sending Http Requests from inside React app to a backend, how do React Apps interact with databases?
React apps or in general browser-side apps, browser-side code, so JS code running in the browsers, should never directly talk to a database. So when we have a React apps, and some kind of database, a SQL database, a NoSQL database like MongoDB, when our database running on some database server. We don’t have to connect directly to the database server from inside our client-side, our browser-side, JS code you would expose your database credentials in that code. Because you must never forget that all JavaScript code running in the browser can be accessed and read, not just by the browser, but also by the users of your website. Simply open up the developer tools and you can view all the code there. For example, credentials that allow access to a database. In addition, directly connecting to a database could also bring other problems like performance issues but the security problem is the biggest problem of all.
O therefore, instead of directly talking to a database from inside our reactive code, we always take another rout. We have a backend application running on the another machine, not running in the browser, but running on some server out there, maybe on the same server as the database often on a different server, though. Now this backend application can have written with any server-side language of our choice, NodejS, PHP, ASP.NET, everything is possible, which will do talking to the database because you can safely store and use database credentials on the Backend application since that Backend code cannot be viewed by our users. So the React will talk to that backend server , backend API which is a server which exposes different URL’s requests can be sent to. Then we have a safe connection to the database because the credentials are on this backend app. for talking to the Backend app no security relevant details are needed.

For example, for a movies app we use starwars API, it is not a database. Behind the scene, it uses some database to store some data about the star wars movies, but we interact with this backend app.
When we talk about APIs in the context of HTTP requests, we typically talk about RESR or GraphQL APIs which are basically two different standards for how a server should expose its data. Startwars API is a RESt API, and it simply means that there are a couple of URLs which you send that request to get back data in certain format. Different URLs which you send different requests will give you different chunks of data. That's what makes it an API.
There is a package called axios which makes sending HTTP requests and dealing with responses very simple, no matter which JS library you might be using. 
We also have a build-in mechanism for sending HTTP requests from inside JS that is the Fetch API. The Fetch API is built into browsers and it allows us to fetch data and actually also to send data even though the name doesn’t imply it. We van use that to send HTTP requests and work with responses.
We will use the fetch function making with browser and add the URL for first argument and the second one can be extra header, extra body or change the HTTP request method.
We need to handle the response. The fetch returns a promise (which is an object which will eventually yield some data instead of immediately doing that, because, of course, sending an HTTP request is an asynchronous task. It doesn't finish immediately. It can take a couple of seconds or milliseconds. It can even fail, of course. we can't just continue in the next line of code and use the result immediatelyInstead, the result will be there at some point in the future and that's exactly what promises exist for in JavaScript..) which allows us to then react to the response or any potential errors we might be getting.

As we said we are dealing with promise. We build a chins with then, then() call after then(). But we can also use an alternative syntax, async await. We can add async keyword in front of the function and then await and operation which is returning a promise. It is just a transformation in our code which behind the scenes basically does the same as if we use then blocks. It is just a bit easier to read. It is still asynchronous code with async keyword. It looks synchronous, we execute step after step, but behind the scenes that transform to the syntax with then() calling. We can also store await in the variable and use it.
**Handling loading && Errors && data states**:
We can add a new state for handling loading process. When we are loading we can show a text that is loading. And also we can put a text with this state and length of data that there is movie or not.
For handling an error, we have to use another state that initially might be null because initially we have no error. And here if we are not using async function and use then() for error we use catch to catch any error. But with using async/await we use try{} block catch {} and catch any potential errors. One problem we will face is that the Fetch API doesn’t treat arror status codes as real errors. It will not throw a technical error if we get back an error status code. We have would not result in an error. We would get an error in a second step if we try to operate on data which we haven’t gotten. But that is not how we want to handle this. Instead it would be better if we would throw a real error if we got back a response with an unsuccessful status code (Status codes are issued by a server in response to a client's request made to the server.). The fetch API doesn’t do that, but we could use third-party library which use for sending requests , would generate and throw a real error for error status codes. For finding successful response we can use .ok. The response also has a status field which holds the concrete response status code. You could also manually check that. We Put it before second step of the code that wants to execute. So we know here we got an error when response is not success. And we will make it into the catch block and we call state function for error and set it to error message that we got before.
**using useEffect for requests :** 
Sometimes we want to immediately fetch our data, not with press the button. We can use another concept the useEffect hook. Because sending this http request is a side effect which ultimately changes our components state.
useEffect is great if we have code that should be executed as part of the component renders cycle, but maybe not always when the component re-renders. We use the function that we write for fetching data and handling error in the useEffect and also use it as a dependency. Just for emitting of infinite loop we use the useCallback and put the fetch function in it with empty dependency Even ever something will change in the fetch the useEffect re-render again. So we can see the data immediately when the website will be load.
So we learned how to send a get request, fetch request to the URL. But in the lots of application we don’t want to fetch a data. We also want to send data to the server, for example because a user was created. So for it, we need an API to send post requests there.
So for this purpose we can use Firebase which is a service provided by google. It is a backend which we can use without writing any code. It is not some kind of database but it also gives us a full backend app, a complete rest API, to which we can send requests. We can create a project, and one part of is database we can use it. When we click in the Realtime Database, the very simple database is set up for us. It give you a url, we can use to talk to that database. that's deceiving. Because we cannot talk to the database. The URl to some FireBase API, rest ApI, which takes incoming requests and does talk to some other database behind the scenes.

**Sending a POST request:** 
Fetch is not just for fetching data, we can use it function to send data. We can outsource some code into separate function maybe also stored in other files to keep this file lean. When we want to POST request, the fetch API can get second argument. We can use this second argument to configure outgoing request. For example we can set the method key to “POST” to send the post request. With it, the firebase service creates a resource in the database.
Now what happens exactly when sending a POST request to some URL always depends on the backend we are using. It is not set in stone that sending a POST request will always create a resource but it always depends on the concrete API.
We are working with Firebase that send a POST request will create a resource.

We also need to add that resource which should be stored. In our project we do that with body option in the fetch API configuration object. The body ants JSON data. JSON is the data format which is typically used for exchanging data between frony-end and backend.
Now to convert a JavaScript object to JSON, we can use a utility method which exist in JS. We can use the JSON object which is built into browser side JS (JSON.stringify) and call stringify and this basically takes a JS object or array and turns it JSON format.
And last, We need to add some headers or to be precise, one header which we do by adding the header key and setting an object as a value, that is the content-tyoe which should be set to application JSON.
Technically this header is not required by Firebase, it would be able to handle the request even if that header is not set. But a lot of REST APIs that we might use in future, require this extra header, which describe to content that will be sent.
And then we can get our response data by awaiting response dot JSOn, because Firebase also sends back data in JSON format. We are not getting back in array for data but an object, where the IDs are keys and then the data are nested objects. E need to transform data to display in our format.

# Building Custom Hooks:
We worked with a lot Hooks with the build in react Hooks that React offers to us like useState, useReducer, useEffect and useContext that are special React function that start with Use.
What are custom Hooks? Custom Hooks are just regular functions like build-in Hooks, which can contain stateful logic. We can build custom Hooks, these custom hook functions, to outsource stateful logic into reusable functions. Unlike regular functions, custom Hooks can use other React Hooks and React state. With custom hooks, you can outsource logic which we might be using in different components, into a custom Hook which we can then call all these various components.
When we are building the custom Hook for named them, we have to start with use. That is hard rule which we have to follow. It will be a normal function in the end but the use at their beginning signals to react that it will be a custom Hook and it gives the react to guarantee that we will use that function by respecting these rules of hooks s that we will use this custom Hook function just as we use to build in hooks.
So When we have a function starting with use, React look out for that, and we can start violating some of these rules of hooks.
We use the custom Hook for making a function that we want use it in some place. We will call the custom hook in the other component. If we use React hooks in our custom hook and use the custom hook in another component, the react hooks will be tied to component, and when we use the custom hook in different component every component will receive its own state. We don’t share the stet, just the logic which has shared not the concrete state. 
Like other hooks, like state that we are de-structuring return array and use it, we have to return whatever we want to return and use in other components. It can be an array, object or a number. And set a variable and put the custom hook in it.
For making the custom hook reusable and configurable, we could use arguments , just our component receive props.

# Forms and Handling user input:
Working with value and validation and state. What is complex about forms? Forms can be complex from a developer’s point of view because forms and their inputs can assume a broad variety of different states. They can be invalid or valid. For every state that we have in the form, we have to check it is valid or invalid, not for the overall form. So if one of input is invalid we have to show error massage and highlight problematic inputs and ensure form cannot be submitted or saved. If input is valid, we have to allow and ensure form to be submitted or saved. 
When to validate? 
1.	We can validate the user input when the form is submitted as a whole , here we allow the users to enter a valid value before warning them. It is good to avoid unnecessary warning but maybe present feedback is too late.
2.	we can also check the value entered by a user once an input loses focus to then check what a user did enter the error and find out if it is valid. The good thing it is that we allow the users to enter a valid value before warning them. But we already do show an error then once the user is done with that specific input. We don’t wait for overall form submission but we just wait until the user is done with one specific input. This can be useful for untouched forms. So where users haven’t entered anything yet. The downside with this approach if we only validate on losing focus is that if an input was invalid, now come back to fix ot, after users are done entering an input.
3.	 We can also do that when every keystroke or on every change to user makes to an input. Here we provide direct feedback to the user on whether the input is valid or not on every keystroke. But as a downside, we here warn the user before they even had a chance of entering valid values. Here initially everything is invalid.
But if apply on invalid inputs, It has the potential of providing more direct feedback.
**Dealing with form submission and getting user input values**:
 there two main ways for doing that. 
1.	We can listen on every keystroke and store the value in some state variable. When we work with input we use event object as a agreement to function to get entered value with event.target.value that is a vanilla JS. We can bind the name input change handler to input with onChange event. With this, on every keystroke , the function that we point it to input element, will be fired, and hence the entered name sate is updated. For submit the form we define another function with getting event object, because we bind the function to onSubmit on the form. We also have to use event.preventDefault() to prevent of sending an HTTP request to server and prevent of leading to the page being reloading in the end. When we are building the website, we don’t really have a server that wants to do anything with that request. We just have a static server that serves our JS and HTML files.
2.	We can use ref to fetch the input once the user is done typing in a value. We import useRef and we use it with adding a nameinput ref constant and assigning the value of calling use ref to it. Then we set inputname ref as a ref to input with special ref props which react allows us to set on any HTML element. After adding ref property to input, we can access to value with submitHandler function. For it, we can use the nameIput that variable to ref, and use current property. Current property is on react ref and we have always a current property because ref are always objects with a current property that holds the value we assigned to the ref in input, so with nameInput.current,value we can access to the value. On the other hand, input element in JS, the JS representing, the HTML input element always hols the value currently entered in that input.
Now how we can decide of which on is better, so it depends what we plan to do with the entered value. If we are only interested in it once when the form is submitted, a ref might be better, because logging and updating the state value with every keystroke is bit overkill. But if we want the value after every keystroke, for example for validation, then using the state is better. The another reason for using state instead of ref is when we want to reset the entered input. We can do it with ref, and put current.value to empty, but it is not ideal, because we are directly manipulating the dom. we're using some vanilla JavaScript code to directly reach out to the dom and change something there. And that is typically not something you should do. You should leave that up to react. React should be the only thing manipulating the dom. And therefore this is not ideal, don't manipulate the dom. You can do it and it might be okay, it's up to you ultimately, but it's not a very clean way of using react.

When we get an input and send it to the server, we don’t want to send an empty data to server. we want to say the client-side validation, where we validate in the browser. But it is not completed. If we have a real website, validating in the browser is great, when we get the user a direct feedback. But it is not enough. We have to validates the input on the server, because this code has to be edited by our users. for form making custom hook and put it in the form component is very usful and reusable.

# Diving into Redux
This is very popular third party React Library. Redux is a state management system for cross-component or app-wide state.
We used the useState to manage data and every changing in our app. And we also used useReducer for complex examples. Actually we used the React’s state Management Hooks like useState so that we can tell React that some data changed and so that it then updates the UI for us.
But we can split the definition of state into three kinds of state. We have a 
1. local state: is state so data which changes that affects the UI which belongs to a single component. For example, when we listen to a user input with every keystroke in a state variable. Or we have a button that toggles some detailed field for showing details. So we should be managed component- internal with useState() or useReducer().
2. cross-component: we have often have state that affects not just one component but multiple components that is cross-component state. For example, if we have a button that opens or close a modal overlay such a modal component. The trigger for opening the modal is per definition not inside of the modal. So in such these cases we have multiple components working together to display and hide a modal. We can also implement that with usestate or usereducr we then just need to pass props around so we need to build those prop chains or do this prop drilling ad it’s also called. Where we also might pass functions as props across multiple components so that these different components can work together and manage state together.
3. app wide state: this state affects the entire application (most/ all components). For example, user authentication status. If we log in we might need to change the navigation bar because we now show new options and we also certainly affect a lot of other components which now show more or less data. We can manage this with the useState and useReducer and by passing state values and updating functions around full props. 
Now for cross-component and app-wide state passing around data and updating function through props can be cumbersome though. That why we learned about react context. That makes managing cross-component or application wide sate easier. That is one way to simplify cross-component and app-wide state management.
Redux solves the same problem. So both React context and Redux are there to help us manage such cross-component or app-wide states.
The question here is why we have Redux when we have React Context to manage our components and data? We used the Context for avoiding prop chains or prop drilling and we can have a centeral place our context and the Context Provider component which we use for managing state. 
So why we need Redux?

React Context has a couple of potential disadvantages, we say potential because they might not matter in the app you are building. 
If they don’t matter, we don’t need Redux. We can use both Context and Redux in the same application. Typically for application wide-state, we will only use one of the two, but then we could be using Redux for the general application wide-state, stil use the Context for selected multi-component states which are important in parts of your application. The mixing them like it is possible.
So Redux is basically an alternative to React Context. Redux is all about hsving one central Data store in our application. Whichever cross-component or app wide state we have, it goes into one store. We have this store and when some data change, the React will be update. For this components set up subscriptions to our Central store. They subscribe to the store and whenever the data changes the store notifies components and then components can get the data they need, so they get a slice of the Redux store, and then they can use it. The important rule is how do we change data into stored in? here components are not important, never directly manipulate the store data. We have that subscription, but we don’t have a data flow in the other direction, At least not a direct data flow. Components don’t directly manipulate that data in the store. Instead for debt, we use a concept called reducers. We have a reducer function. This function that we have to set up, is responsible for mutating, changes data. This reducer function here is not that useReducer hook we learned before. Reducer functions are functions which takes some input and then transform that input and spit out a new output a new result. So we have reducer function which is responsible for updating the store data, and we have components that subscribe to that data.
How we can connect the component and reducer function, because ultimately it will be the components that should trigger a data change. We have a third concept here, we have 1. Actions, 2. Components 3. Dispatch actions. Components trigger a certain action, the action is a JS object which describes the kind of operation the reducer should perform. Therefore, redux then forward actions to the reducer, reads that description of the desired operation, and then this operation is performed by the reducer. So components dispatch actions, and this action is forwarded to the reducer, the reducer does what the action wants, and then the reducer spits out a new state which effectively will replace the existing state in that central Data store. When the updated data happened, subscribing components are notified so that they can update their UI.
For using Redux: at first we have to have node.js that we have it, for run JS outside the browser, for create react app and also for using development server.
No we need to npm init in our folder, because after that we need to install Redux with this command npm install redux.
**I get an error for installing it** it resolved with installing a new version of npm.

Npm istall –g npm@latest

For using Redux in the jS file, because we make a regular JS file and now we want to use Redux in it, so we have to import the redux in this file. But because we are going to execute this file with node.js, the import will look a bit different.
Const redux = require(“redux”);
That is the default nodeJS import syntax for importing a third party package ( allows developers to share code that extends the functionality of Django REST framwork).
We import redux from the Redux package with this syntax. Now we need to create a store.
redux.creactStore(reducerFunction) …redux is the object and createStore that is a method exposed by react library.
Const store = redux.createStore(reducerFunction)
Next thing that we need is the reducer function that is a standard JS function but it will be called by Redux library. It will be always receiving two pieces of input. Two parameters, the old or existing state and the action that was dispatched. It always must to return a new state object. Therefore, a reducer function should be a pure function. Same input same output without side effect. We must not send a HTTP request or write something to local storage or fetch something from local storage there. A reducer should really just be a function that takes the given inputs, which are provided by Redux and then produces the expected output, a new state object, or any kind of value type. We have to put a initial state for state in the reducer function, because of first executing.

Cinst reducerFunction = (state = initial state, action) => {…}

We pass the reducer function into the store. The store now know about which reducer function is responsible for changing that store. 
Now we ned someone who subscribes to that store and then we need an action that can be dispatched.
For subscriber if it is a function we can reach out to store, and use getState() getState() is a method which is available on the store created with createStore(),it will give us the latest state snapshot after it was updated.
 we need to tell the subscriber function should be executed whenever our state change. we do it with calling the subscribe () method on the store >>> store.subscribe(). The subscribe method then wants a subscriber function, the function which redux will executed for us whenever the data and the store changed, store.subscribe(subscriberFunction). We will point to the functions, reducer function or subscriber function, because both execute with redux.
Without action the subscriber function isn’t executed. So for it, we use dispatch() method, it is a method which dispatch an action, an action is a JS object with a type property. Typically, you use a string here and then this should be a unique string so that every action, every distinct action, which you dispatch leads to different things being done in the reducer.
Redux it indeed isn't a library restricted to React, we can use redux in any JS project.

**React-redux:**

To making working with Redux applications easier, there is a second package which we should install the 
react-redux 
package. This is a package which makes connecting react applications to redux stores and reducers ends on very simple. With it when we want to use redux in react project we write:
Import { createStore } from “redux”;
And for using this file outside we need to export store. Now for using it in our React project we nedd to provide it. What does provide mean here? To provide our Redux store to the React app, we go into index.js file where we rendered the entire app, to the highest level we can go in our react application, to the top of component tree, where we render the root component. Here we must import:

Import { Provider } from “react-redux”;

Provider is a component. And wrap the <App /> with provider. BUT we don’t have to use Provider on this highest component level, we could also wrap nested components with provider. So that component and child component and child o child can access to Provider. We also have to import store in this component and in the Provider tag we have a store prop which have to set with a value that is our Redux store:

<Provider store={store}>….
  
Now we go to the component that we want to use the data in store, so we import the useSelector from react-redux. useSelector is a custom hook made by the react Redux team. There also is useStore hook which we could use as well that gives us direct access to the store. But useSelector is a bit more convenient to use because that allows us to automatically select a part of our state managed by the store.
  
Now if we would be using a class-based component and not a functional component as we are here and as we are in the majority of the course, then there also is a connect function which we could use instead. This function can be used as a wrapper around our class component to connect that class component to the store.
When we pass the function for getting the special data, the great thing is that when we use useSelector react redux will automatically set up a subscripton to the redux store for this component. So our component will be updated and will receive the latest state automatically whenever that data changes in the Redux store.
Now for dispatch actions, we use the useDispatch hook that give back a dispatch function which we can execute and dispatch an action against our Redux store.
But for class-base components how do we get access to Redux here?
In the functional component we used hooks. Use dispatch and use selector, but hooks are not usable in class-based components. Now, I briefly did mention it before, react Redux also exports a connect function, which is a function that helps you connect class-based components to Redux. Actually, you could also use it on functional components, but for functional components, using these hooks is simply more convenient. But no matter if it's a functional or a class-based component, you can use connect. And therefore we will use connect here on this class-based component. How do we use it? When we export our counter, we don't export the counter component like this. Instead we call connect and now connect when executed, will actually return a new function as a value, which we then execute again. And then we pass our component to that returned function as our argument. So this can look strange, but connect is a so-called higher order component. We execute the connect function. It then returns a new function, and we execute this returned, this new function as well.  And to this returned function, we pass counter. Now, why do we do it like this? Because to connect, when we execute this, we also pass something. Connect also wants some arguments. Connect also wants some arguments. It wants two arguments to be precise, and both arguments are functions. I'll write them separately here. The first function is a function that maps Redux state to props, which will be received in this component then. Hence we call this function map state to props. That's not a name you must use, but a convention which you will see in a lot of projects. Now, this is a function which receives the Redux state, and then this returns an object where the keys will be available as props in the receiving component. So in the counter component, and the values of those keys, that is then the logic for drilling into that Redux state. So here we could expose a counter prop by using counter as a key here, this key named therefore is up to you. And the value is state.counter. So we then pick the counter value from the Redux state, and bind that value to the counter prop.
About the object that we return into our reducer in Redux that we always return a brand new snapshot, a brand new state object that Redux will use to replace its existing state with. The important point here is that the objects which we return in the reducer will not be merged with the existing state. They will overwrite the existing state. So if we forget to put a some of property in the object we get undefined and it doesn’t work normal. We must always set all the other states when we update a piece of state, because we overwrite the old state.
  
It is super important when working with redux, WE SHOULD NEVER MUTATE THE STATE, THE EXISTING STATE, WE SHOULD NEVER CHANGE THE EXISTING STATE. It makes a bug in your code, if you change the existing object.
**Redux Challenging & Introducing Redux Toolkit:** 
let's identify a couple of potential problems we could be facing here if our application would continue to grow. So if we manage more and more state with Redux one potentioal issue can be our action types. 
Another potential problem we could be facing is the state immutability which we have to respect. We have to ensure that we always return a brand new state snapshot and that we don’t accidentally change the existing state anywhere. If we have more complex data with nested objects and arrays it is easy to mess this up and accidentally change some nested data even though you didn’t want to. 
For all these problem there are solutions, we could implement on our own. For ensuring that we have unique identifiers and we don’t miss type we could create constants. There are also solutions for splitting your reducer into multiple smaller reducer functions. There are also third-party packages which allow you to automatically copy state and ensure that we don’t accidentally edit it. But we don’t need to dive into those various solutions anymore, instead there is another library called Redux Toolkit. Redux toolkit is developed by Redux team, and as an extra pakage which makes working with Redux more convenient and easier. For install redux toolkit:
  
Npm install @reduxjs/toolkit
  
When we install it we can unstill redux because redux is in reduxToolkit. We will use it in the store folder. It will simplifies a couple of aspects of working with redux.
We import:
  
Import { createSlice } from “@reduxjs/toolkit;
  
There is createReducer in @reduxjs/toolkit but createSlice is more powerful thane createReducer. with createSlice is we are preparing a slice of our global state. we we have different pieces of state  which are not directly related, we could make different slice in s eparate files. every slice needs a name. 
With createSlice and in the method that we have, we can change the form of state, because redux toolkit with another package called imgur change our state and make a clone of existing state with ours.
After making the CreateSlice object we need to use the return value of callimg createSlice, we pass it into store in this way, with reducer:
  
creatStore(creatSliceName.reducer)
  
when reducer is big with some if statements, togger to different reducer method. When we have small state slices we can do it. But for big app it doesn’t a good idea. So for multiple reducer >>> for redux we have combineReducers, but for reduxjs/toolkit we can import configureStore. ConfigureStore like createStore creates a store but it makes merging multiple reducers into one reducer easier thereafter. So here we can now call configureStore, and to configureStore, we now pass an object not a reducer function but an object. It is a configuration object expected by configureStore. A configuration object where we then set a reducer property, reducer singular and not reducers plural, because still no matter if we use createStore or configureStore, redux wants one main reducer function which is responsible for the global state. If we have multiple state slices in big app, then alternatively as a valu for ths reducer key, we could also set an object and in the object, we can set up keys of our choice. In the behind the since they will be merged into one big reducer.
Now how we can dispatch actions? We have to export actions besides the exporting store.
  # Redux and side Effects (and Asynchronous code):
There is an important rule, that is the reducers must be pure, side-effect free, and synchronous. So our reducer functions should take some input (in the case of the Redux reducer the old state and the action) and then produce some output (new state). The reducer function we pass to use reducer, is react hook, works in the same way. It has nothing to do with Redux, but it is just general reducer concept, that we have pure side effects synchronous function that takes input and produce some output, without any asynchronous code that blocks it, no code of that kind must be part of your reducer functions. But when woring with reux, when we dispatch some action that woud involve a side effect, like HTTP involve a side effect, like HTTP request that should be sent, where should we then put the side effect code? Where should we put our asynchronous code when working with Redux? Because reducer function is clearly the wrong place.
The awnser to these questions is that we have two possible places where we have can put our side effects.
1.	We can pt our side effects, asynchronous code directly into the component with user fact, then we only dispatch an action once that side effect is done, redux doesn’t know anything about that side effect.
2.	We can write our own action creator functions, we don’t use the automatically generated ones redux toolkit gives us but instead we write our own action creators. It turns out that for those action creators redux actually has a solution that allows us to perform side effects and run asynchronous tasks as part this action creators without changing the reducer function.

Whenever we edit the cart, because we add items or we reduce the quantity or remove items, we want to send the request to a backend server to store that updated cart on the backend. Also hen we reload front-end app we can fetch that saves cart from the server load it and display it.
When we have any code that produce a side effect or is asynchronous like sending an http request, such code must not go into reducer functions. So where should side-effects and async tasks be executed? 
1.	We can execute it in the components (useEffect()). For it we use useSelector in the component and get state without mutate them, and then we send the request. We have to copy the state and change them and use them, and also store them. The problem is that if we would use this in all the parts of our app where we need to update the cart. There is another problem, we do the data transformation in some helper function and in the end directly in our components. We don’t do our transformation in our reducers.  All this code here just transforms data. It's synchronous code and side effect free. So if we basically just have some data transformation so should prefer reducers. Now, if you personally have a different opinion if you like having your code in the component that of course is fine, but generally it is considered a bit better to prefer reducers and a wide action creators or components for that. we did definitely work a lot with components and you want to avoid putting your data transformation code there when working with Redux. It would be different for asynchronous code or code with side effects. There you should prefer action creators or components and you absolutely must never use reducers. But if we want to sync our new state to the server, we want to update the server with new state, we can first do the work in front end and let redux update its store, and in the second step we send the request to the server. We don’t need to do that inside the reducer function where we wouldn't be allowed to do it. We do in it in the other component. Here we use useEffect to watch for changing in our cart, because we know useEffect allows us to run side effects.
2.	We can create something which is called the action creator which used indirectly and allow us to run asynchronous code or generally any side effect code. We use the action creator in previous approach, but we can also create our own action creators to so-called thunks. Thunk is a function that delays an action until later, till something else finished. An action creator function that does NOT return the action itself but another function which eventually returns the action. For example, we're creating a function, send carts data, which immediately, without doing anything else, returns another function, an async function. We don't know yet who will execute that function, but we will soon to know it. But in that function, we then dispatch a notification, action. Then we create a new function, so yet a never nested function, which we create on the fly, which has also async, in there we send the request. This function is then called by us, instead of try-catch, simply to handle any errors. If we don't have an error, we dispatch the success notification.  If we do have an error, we dispatch the error notification.
the great thing about Redux, when using Redux toolkit, is that it's prepared for that.  It does not just accept action objects with a type property. Instead it also does accept, action creators that return functions.And if it sees, that you're dispatching, a action which is actually a function, instead of action object, it will execute that function for you. So Redux will execute that function for you. And with that function, I mean this function here, it will give us that dispatch argument automatically. So that in that executed function, we can dispatch again, because there's a such a common pattern that we wanna have action creators that can perform side effects. And that can then dispatch Abra actions, which eventually reached the reducers, as part of a flow off side-effects, or as a flow of steps that should be taken. And that's what we have here. So we can use a function that returns another function, as a action as well. That is built into Redux when using Redux toolkit.
Now we want to use the Firebase as our backend. Backend programming language like Node.js or PHP, we have to know about them. It is important to recognize that the code we need to write on the frontend and where we write that code will depend on our backend code. Because we have our backend API, our backend server talking to or frontend app with help of this http request and the responses which we send around. If we have a backend API that does a lot of work so that does not just store incoming data but also transform it. If we have an API then our frontend app could do less work. It could just send data for a product that should be added to a cart. It could send that data to the backend, lets the backend do the transformation and then use the response on the frontend.
But when we work with Firebase, it doesn’t do a lot of work, it just stores incoming data in format it receives it in.
For sending request to firebase to store data we send the POST request, but here we want to send a PUT request. If we send a PUT request we also do store data on firebase but the difference to POST is that the new data will not be added in a list of data, it will overwrite existing data with incoming data. We face one problem when using useEffect the way we currently do it: It will execute when our app starts. Why is this an issue? It's a problem because this will send the initial (i.e. empty) cart to our backend and overwrite any data stored there.


